import pandas as pd
from gensim.models import Word2Vec
import numpy as np
import os # For saving/loading the model and matrix
import joblib # For efficient saving/loading of numpy arrays

# Define file paths
classified_log_file = 'classified_logs.csv'
word2vec_model_path = "word2vec_log_events.model"
log_sequence_matrix_path = "log_sequence_matrix.joblib" # Path to save the matrix

# --- Step 1: Load the classified log data ---
try:
    df_classified = pd.read_csv(classified_log_file)
    print(f"'{classified_log_file}' loaded successfully.")
    print(f"Shape of df_classified: {df_classified.shape}")
except FileNotFoundError:
    print(f"Error: '{classified_log_file}' not found. Please ensure it's in the same directory and was generated by the previous script.")
    exit()

# Extract the sequence of EventIds
event_id_sequence = df_classified['EventId'].tolist()
print(f"Total EventIds extracted: {len(event_id_sequence)}")
if len(event_id_sequence) == 0:
    print("EventId sequence is empty. Cannot proceed with windowing or Word2Vec training.")
    exit()

# Define window parameters
window_size = 3
stride = 1

# --- Step 2: Generate log sequence events (lse) using a sliding window (ALWAYS) ---
log_sequence_events = []
# Ensure there are enough events for at least one window
if len(event_id_sequence) >= window_size:
    for i in range(0, len(event_id_sequence) - window_size + 1, stride):
        window = event_id_sequence[i : i + window_size]
        log_sequence_events.append(window)
else:
    print(f"Not enough events ({len(event_id_sequence)}) to create a window of size {window_size}. Cannot generate LSEs.")
    exit()

print(f"Generated {len(log_sequence_events)} log sequence events (lse) with window size {window_size} and stride {stride}.")
print("First 5 generated LSEs:", log_sequence_events[:5])

if not log_sequence_events:
    print("No log sequence events generated. Word2Vec training cannot proceed.")
    exit()

# --- Step 3: Train or Load Word2Vec Model ---
model = None # Initialize model variable
if os.path.exists(word2vec_model_path):
    print(f"\nWord2Vec model '{word2vec_model_path}' found. Loading model directly...")
    try:
        model = Word2Vec.load(word2vec_model_path)
        print("Word2Vec model loaded successfully.")
    except Exception as e:
        print(f"Error loading Word2Vec model: {e}")
        print("Attempting to re-train the model as loading failed.")
        # Proceed to training block if loading fails
else:
    print(f"\nWord2Vec model '{word2vec_model_path}' not found. Starting Word2Vec model training...")

if model is None: # Only train if model was not loaded successfully
    try:
        model = Word2Vec(sentences=log_sequence_events, vector_size=100, window=5, min_count=1, workers=4)
        print("Word2Vec model training completed successfully.")
        model.save(word2vec_model_path)
        print(f"Word2Vec model saved successfully as '{word2vec_model_path}'")
    except Exception as e:
        print(f"An error occurred during Word2Vec training or saving: {e}")
        import traceback
        traceback.print_exc()
        exit() # Exit if training fails

# --- Step 4: Average the Vectors for each Log Sequence Event (lse) ---

def sequence_to_vector(sequence, model):
    """
    Converts a sequence of event IDs into a single vector by averaging their Word2Vec embeddings.
    """
    vectors_in_sequence = []
    for event_id in sequence:
        if event_id in model.wv:
            vectors_in_sequence.append(model.wv[event_id])
    if vectors_in_sequence:
        return np.mean(vectors_in_sequence, axis=0)
    else:
        print(f"Warning: No valid vectors found for sequence: {sequence}. Returning zero vector.")
        return np.zeros(model.vector_size)

print("\nConverting log sequences to vectors by averaging...")
lse_vectors = []
for i, lse in enumerate(log_sequence_events):
    lse_vec = sequence_to_vector(lse, model)
    lse_vectors.append(lse_vec)

# Convert the list of NumPy arrays into a single NumPy array (your "Log Sequence Matrix")
log_sequence_matrix = np.array(lse_vectors)

print(f"Created Log Sequence Matrix with shape: {log_sequence_matrix.shape}")
print("First 3 rows of the Log Sequence Matrix (first 5 dimensions):")
print(log_sequence_matrix[:3, :5])

# --- Step 5: Store the Log Sequence Matrix ---
try:
    joblib.dump(log_sequence_matrix, log_sequence_matrix_path)
    print(f"Log Sequence Matrix saved successfully to '{log_sequence_matrix_path}'")
except Exception as e:
    print(f"Error saving Log Sequence Matrix: {e}")

# The 'log_sequence_matrix' variable now holds the NumPy array in memory.
# It's also saved to disk for future use.